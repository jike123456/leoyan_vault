1. 链表
	1. ListNode* head：`ListNode*` 意思是这是一个指向节点的**指针**。`head` 是这个指针的名字，通常叫做“头指针”。只要拿着 `head`，我们就能找到整条链表
	2. for (ListNode* p = head; p != nullptr; p = p->next)：这里我们定义了一个**新的临时指针**，名字叫 `p`；`nullptr` 是 C++ 中的空指针，代表“后面没有路了；`p->next` 是当前节点里存的“下一节车厢的地址”
	3. 右边不变左边变
	4. 。。。。是（=）。。。
	5. `void`（无返回值）；return；
	6. **类内部调用**：因为我们是在 `DoublyLinkedList` **类的内部** 写这个函数，所以直接调用 `push_front(val)` 就行了，不需要加 `list.` 前缀（`this->` 是隐含的）
2. 哈希表：key是唯一的（类比索引）；value则是随意的。
	1. 位运算
	2. 哈希函数
	3. 哈希冲突
	4. 扩容机制
3. 二叉树:
	1. 节点；叶子节点；根节点；父子节点：储存着数据
	2. 分类
		1. 满二叉树：金字塔，除了叶子节点其他节点都是满的
			1. 假如有k层，则有2^k -1个节点
		2. 完全二叉树：打字一样
			1. 从上到下：上层没填满，不填下面
			2. 从左到右：左边没填满，不填右边
		3. 二叉搜索树：收纳专家
			1. 对于任何节点，左边必须比右边小，从小到大排列![[Pasted image 20251209102554.png]]![[Pasted image 20251209113459.png]]
	3. 遍历方式逛法：前序、中序、后序（根据根节点的顺序）
		1. 前序：根节点在最前
			1. 应用：复制一棵树
			2. 先把左边的树遍历完。![[Pasted image 20251209104325.png]]a - b -d -c
		2. 中序：中间
			1. 应用：
		3. 后序：最后
			1. 删除一棵树
			2. DBCA
	4. 嵌入式开发习惯：用完记得手动释放内存delete nodeD; delete nodeC; delete nodeB; delete nodeA;
	5. 迭代代替递归：
		1. 嵌入式的单片机的ram非常金贵，没办法进行套层，还保留之前的，一直等他回来
		2. ### 3. 怎么办？（面试常考题）
           既然递归有风险，我们在嵌入式里处理深层树结构时，通常会用 **“迭代法 (Iteration)”** 来代替递归。
           简单说，就是**自己手动造一个小栈**（用 `std::stack` 或数组），模拟递归的过程，但是把控制权抓在自己手里，用 `while` 循环来处理。这样就不会无限制地消耗系统栈空间了。
           