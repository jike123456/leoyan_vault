# 3.7 [串口]封装常用功能

## 1. 为什么要封装串口的常用功能？
在之前的课程中，我们将串口的初始化、发送、接收代码散落在 `main.c` 或直接堆砌在一起。为了提高代码的**可移植性**、**可读性**和**模块化**程度，我们需要将串口功能封装成一个独立的模块（Driver）。
*   **解耦**：主函数 `main.c` 不需要关心底层是如何配置寄存器的，只需要调用 `Serial_Init()`、`Serial_SendString()` 等高层接口。
*   **复用**：将来在其他工程中需要使用串口时，只需将 `Serial.c` 和 `Serial.h` 复制过去，包含头文件即可直接使用，无需重复造轮子。
*   **清晰**：`Serial.c` 负责干脏活累活（操作硬件），`main.c` 负责业务逻辑。

## 2. MyLib 文件夹简介
为了管理我们自己编写的驱动代码，建议在工程目录下建立一个专门的文件夹，例如 `Hardware` 或 `MyLib`。
*   **结构建议**：
    *   `User`: 存放 `main.c`, `stm32f10x_it.c` 等应用层代码。
    *   `Library`: 存放 STM32 标准库文件。
    *   `Start`: 存放启动文件和内核文件。
    *   **`MyLib` (或 Hardware)**: 存放我们封装的 `Serial`, `LED`, `Key` 等外设驱动模块。
*   **配置工程**：
    1.  新建文件夹 `MyLib`。
    2.  在 Keil 左侧工程树中右键 "Manage Project Items"，新建 Group 命名为 `MyLib`。
    3.  将 `Serial.c` 等文件添加到该 Group 中。
    4.  **关键**：点击 "Magic Wand" (魔术棒) -> C/C++ -> Include Paths，将 `MyLib` 文件夹的路径添加进去，否则编译器找不到 `.h` 头文件。

## 3. 复制串口的初始化代码
在 `Serial.c` 中，我们将初始化代码封装在 `Serial_Init` 函数中。

```c
#include "stm32f10x.h"

void Serial_Init(void)
{
    // 1. 开启时钟 (USART1 和 GPIOA)
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
    
    // 2. 配置 GPIO (PA9=TX, PA10=RX)
    GPIO_InitTypeDef GPIO_InitStructure;
    // PA9 TX 复用推挽输出
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
    
    // PA10 RX 浮空输入或上拉输入
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
    
    // 3. 配置 USART
    USART_InitTypeDef USART_InitStructure;
    USART_InitStructure.USART_BaudRate = 9600;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    USART_Init(USART1, &USART_InitStructure);
    
    // 4. (可选) 开启接收中断
    USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
    
    // 5. (可选) 配置 NVIC (如果开启了中断)
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&NVIC_InitStructure);
    
    // 6. 开启串口
    USART_Cmd(USART1, ENABLE);
}
```

## 4. 串口发送相关的函数
这些函数是对 `USART_SendData` 的进一步封装，方便发送不同类型的数据。

```c
// 发送一个字节
void Serial_SendByte(uint8_t Byte)
{
    USART_SendData(USART1, Byte);
    while (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);
}

// 发送数组
void Serial_SendArray(uint8_t *Array, uint16_t Length)
{
    uint16_t i;
    for (i = 0; i < Length; i ++)
    {
        Serial_SendByte(Array[i]);
    }
}

// 发送字符串
void Serial_SendString(char *String)
{
    uint8_t i;
    for (i = 0; String[i] != '\0'; i ++)
    {
        Serial_SendByte(String[i]);
    }
}

// 发送数字 (查看之前的 Pow 函数实现)
void Serial_SendNumber(uint32_t Number, uint8_t Length)
{
    // ... 具体实现见 3.4 节 ...
}

// 封装 printf (需要引入 stdio.h 和 stdarg.h)
void Serial_Printf(char *format, ...)
{
    char String[100];
    va_list arg;
    va_start(arg, format);
    vsprintf(String, format, arg);
    va_end(arg);
    Serial_SendString(String);
}
```

## 5. 串口接收相关的函数
对于接收，为了在 `main.c` 中方便地获取数据（特别是使用中断法时），我们可以封装几个“Get”函数。

*   **设计思路**：中断函数负责把数据存到一个变量（例如 `Serial_RxData`）并置位一个标志（例如 `Serial_RxFlag`）。主函数通过读取这个标志来判断是否有新数据。

**Serial.c 中新增变量和函数**：
```c
uint8_t Serial_RxData;
uint8_t Serial_RxFlag;

// 中断服务函数
void USART1_IRQHandler(void)
{
    if (USART_GetITStatus(USART1, USART_IT_RXNE) == SET)
    {
        Serial_RxData = USART_ReceiveData(USART1);
        Serial_RxFlag = 1; // 置标志位，告诉主循环有数据来了
        USART_ClearITPendingBit(USART1, USART_IT_RXNE);
    }
}

// 获取接收标志位 (读后自动清除)
uint8_t Serial_GetRxFlag(void)
{
    if (Serial_RxFlag == 1)
    {
        Serial_RxFlag = 0;
        return 1;
    }
    return 0;
}

// 获取接收到的数据
uint8_t Serial_GetRxData(void)
{
    return Serial_RxData;
}
```

**在 main.c 中使用**：
```c
if (Serial_GetRxFlag() == 1)
{
    uint8_t RxData = Serial_GetRxData();
    // 处理 RxData
    Serial_SendByte(RxData); // 比如回显
}
```
这种方式完美实现了**中断接收**与**主循环处理**的解耦。
