# 3.3 [串口]为串口初始化IO引脚

## 1. USART模块简介（引脚分布）
STM32的USART外设并不直接占用固定的专用引脚，而是通过**GPIO复用（Alternate Function）**的方式引出。在使用前，必须查阅芯片数据手册的“引脚定义”表，找到对应的物理引脚。

*   **STM32F103 常见USART引脚定义**：
    | 外设 | TX (发送) | RX (接收) | 总线 (决定时钟) | 备注 |
    | :--- | :--- | :--- | :--- | :--- |
    | **USART1** | **PA9** | **PA10** | **APB2** (72MHz) | 最常用，通常映射到USB转串口 |
    | **USART2** | **PA2** | **PA3** | **APB1** (36MHz) | |
    | **USART3** | **PB10** | **PB11** | **APB1** (36MHz) | |

## 2. USART的基本用法（硬件连接）
从IO引脚的物理连接角度来看，进行串口通信时需遵循以下规则：

1.  **交叉连接**：
    *   STM32的 **TX** (发送引脚) 接对端设备的 **RX**。
    *   STM32的 **RX** (接收引脚) 接对端设备的 **TX**。
2.  **共地 (GND)**：通信双方的GND必须连接在一起，建立统一的参考电位。
3.  **电平匹配**：
    *   STM32引脚为 **TTL电平** (0V/3.3V)。
    *   若连接电脑USB，需使用 **USB转TTL模块** (如CH340, CP2102)。
    *   严禁直接连接 RS232接口 (±12V)，否则会烧毁引脚。

## 3. 移位寄存器和串并转换（与IO的关系）
虽然移位寄存器是USART内核的一部分，但它直接决定了IO引脚的行为：
*   **发送 (TX引脚)**：发送移位寄存器将并行数据一位一位地移出，通过 **TX引脚** 输出高低电平序列。
*   **接收 (RX引脚)**：**RX引脚** 采集外部的高低电平序列，送入接收移位寄存器拼装成并行数据。
*   **IO配置的意义**：为了让USART内核能控制IO引脚，TX引脚必须配置为**复用推挽输出**模式，这样引脚的控制权才会被移交给片上外设（USART），而不是由CPU控制的通用GPIO。

## 4. 数据帧格式（引脚波形表现）
数据帧格式的设置决定了IO引脚上电平变化的逻辑：
*   **空闲状态**：IO引脚保持 **高电平**。
*   **起始位**：IO引脚拉低1个位宽 (**低电平**)，标志传输开始。
*   **数据位**：IO引脚根据数据内容变化电平 (低位先行)。
*   **停止位**：IO引脚拉高 (**高电平**) 并保持，标志传输结束。

## 5. 波特率的设置方法（信号宽度）
波特率决定了IO引脚上每一个比特位（Bit）持续的时间长度。
*   例如 **9600波特率**：每个位持续时间约为 $1/9600 \approx 104 \mu s$。
*   在初始化IO时，我们需要确保GPIO的速度设置（`GPIO_Speed`）能够满足波特率的要求。虽然串口速度通常较慢（50MHz的GPIO速度绰绰有余），但配置正确的速度有助于信号完整性。

## 6. 编程接口（GPIO初始化代码）
这是本节的核心内容。初始化串口IO引脚通常包含三个步骤：开启时钟、配置TX引脚、配置RX引脚。

### 6.1 核心配置原则
*   **TX (发送脚)**：必须配置为 **复用推挽输出 (GPIO_Mode_AF_PP)**。
    *   *原因*：推挽保证驱动能力，复用（AF）将引脚控制权交给USART外设。
*   **RX (接收脚)**：通常配置为 **浮空输入 (GPIO_Mode_IN_FLOATING)** 或 **上拉输入 (GPIO_Mode_IPU)**。
    *   *原因*：串口空闲时为高电平，上拉输入可以防止引脚悬空时的误触发；浮空输入则是标准做法。

### 6.2 代码示例 (以USART1为例)

```c
#include "stm32f10x.h"

void Serial_Pin_Init(void)
{
    // 1. 开启时钟
    // USART1 和 GPIOA 均挂载在 APB2 总线上
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
    
    GPIO_InitTypeDef GPIO_InitStructure;
    
    // 2. 配置 TX 引脚 (PA9)
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; // 【关键】复用推挽输出
    GPIO_Init(GPIOA, &GPIO_InitStructure);
    
    // 3. 配置 RX 引脚 (PA10)
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;   // 【推荐】上拉输入，也可以用浮空输入
    GPIO_Init(GPIOA, &GPIO_InitStructure);
    
    // 接下来可以调用 USART_Init 进行串口参数配置...
}
```

### 6.3 代码示例 (以USART2为例)
注意USART2挂载在APB1总线上，但其引脚PA2/PA3所属的GPIOA仍在APB2。

```c
// 开启时钟
RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE); // USART2 在 APB1
RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);  // GPIOA 在 APB2

// 配置 TX (PA2) -> 复用推挽
GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
// ... (其他参数同上)
GPIO_Init(GPIOA, &GPIO_InitStructure);

// 配置 RX (PA3) -> 上拉输入
GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
// ...
GPIO_Init(GPIOA, &GPIO_InitStructure);
```