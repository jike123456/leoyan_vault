1. 协议层配置 (配置串口的大脑)
```cpp
RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE); // 1. 给串口外设供电（开启时钟）
USART_InitTypeDef USART_InitStructure;                 // 2. 定义结构体（填表单）
USART_InitStructure.USART_BaudRate = 115200;           // 波特率
USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx; // 模式：既发送也接收
USART_InitStructure.USART_StopBits = USART_StopBits_1; // 停止位 1
USART_InitStructure.USART_WordLength = USART_WordLength_8b; // 数据位 8
USART_InitStructure.USART_Parity = USART_Parity_No;    // 无校验
USART_Init(USART1, &USART_InitStructure);              // 3. 提交表单，初始化
```
2. 路由层配置 (重映射的关键)
```cpp
RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE); // 1. 开启AFIO时钟（必须！）
GPIO_PinRemapConfig(GPIO_Remap_USART1, ENABLE);      // 2. 拨动开关，把USART1的线路从PA9/10切到PB6/7
```
**理解**：默认情况下USART1连在PA9/PA10。你想用PB6/PB7，就需要像扳动铁轨岔道一样进行“重映射”。**凡是涉及到引脚功能改变（重映射）或外部中断，都必须开启 AFIO 时钟。**

3. 物理层配置 (配置GPIO引脚)
```cpp
GPIO_InitTypeDef GPIO_InitStruct;
RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); // 开启GPIOB的时钟

// --- 配置 TX (发送引脚 PB6) ---
GPIO_InitStruct.GPIO_Pin = GPIO_Pin_6;
GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP; // 重点：复用推挽输出
GPIO_InitStruct.GPIO_Speed = GPIO_Speed_10MHz;
GPIO_Init(GPIOB, &GPIO_InitStruct);

// --- 配置 RX (接收引脚 PB7) ---
// RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); // 这句重复了，可以删掉
GPIO_InitStruct.GPIO_Pin = GPIO_Pin_7;
GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;   // 重点：上拉输入 (或浮空输入)
GPIO_Init(GPIOA, &GPIO_InitStruct);          // <--- 【这里有Bug！】
```
- **TX (PB6)**：必须配置为 **`GPIO_Mode_AF_PP` (复用推挽输出)**。
    - _为什么？_ 因为此时控制引脚高低电平的不是普通的GPIO控制器，而是USART1这个外设，所以是“复用（AF）”。
- **RX (PB7)**：通常配置为 **`GPIO_Mode_IPU` (上拉输入)** 或 `GPIO_Mode_IN_FLOATING`。
- 