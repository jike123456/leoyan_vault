# 二叉树基础与常见类型
节点：储存着数据
1. 叶子节点；没法再分出节点
2. 根节点；最上方没有父节点的节点
3. 父子节点：上下方相连的节点
注意点：二叉树一个节点只能分出两个节点
## 几种常见的二叉树
1. 满二叉树：除了叶子节点，0每一层节点都是满的。![[Pasted image 20251210181833.png]]
	1. 个数为2^k -1
2. 完全二叉树：靠左排列的二叉树，除了最后一层，其他每层都是满的。![[Pasted image 20251210182457.png]] 这种格式，只要进行编号就可以很方便的用数组进行储存。
3. 二叉搜索树：对于树中的每个节点，其**左子树的每个节点**的值都要小于这个节点的值，**右子树的每个节点**的值都要大于这个节点的值。你可以简单记为「左小右大」。==收纳专家==                                                 ![[Pasted image 20251210183012.png]] **因为左小右大的特性，可以让我们在 BST 中快速找到某个节点，或者找到某个范围内的所有节点，这是 BST 的优势所在**。
4. 高度平衡二叉树：是一种特殊的二叉树，**它的「每个节点」的左右子树的高度差不超过 ![[Pasted image 20251210183537.png]] 
**假设高度平衡二叉树中共有 N个节点，那么高度平衡二叉树的高度是 O(log⁡N)**。
    ![[Pasted image 20251210183702.png]] ![[Pasted image 20251210183743.png]] **极度不平衡** 
5. 自平衡二叉树：如果我们可以在增删二叉树节点时对树的结构进行一些调整，那么就可以让树的高度始终是平衡的，这就是自平衡二叉树（Self-Balanced Binary Tree）。
## 二叉树的实现方式
1.**==指针法==**
    class TreeNode {
	public:
	    int val;==宝藏数据==也就是储存的数据
	    TreeNode* left; ==下一个宝藏的线索==  左指针。
	    TreeNode* right;右指针。
	    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
	};==构造整个宝箱==初始化快捷键，不然一个节点得进行三四行
	- **TreeNode node = new TreeNode(); // 造个空箱子
	node->val = 1;                   // 放钱
	node->left = nullptr;            // 把左纸条擦干净
	node->right = nullptr;           // 把右纸条擦干净**
	
	// 你可以这样构建一棵二叉树：
	TreeNode* root = new TreeNode(1);根节点
	root->left = new TreeNode(2);==`new` 表示**动态内存分配**==
	root->right = new TreeNode(3);
	root->left->left = new TreeNode(4);
	root->right->left = new TreeNode(5);
	root->right->right = new TreeNode(6);
	
	// 构建出来的二叉树是这样的：
	//     1
	//    / \
	//   2   3
	//  /   / \
	// 4   5   6
- **如果不由 `new` (在栈上创建)**：`TreeNode node1(1);`
    
    - 这些节点是“局部变量”。一旦函数结束（比如构建树的这个函数运行完了），这些变量就会被系统自动销毁。你的树也就消失了。
        
- **使用 `new` (在堆上创建)**：
    
    - 这些节点会一直存在，直到你手动删除它们（`delete`）。这样你就可以在函数里建树，把 `root` 指针传给别人，别人依然能访问这棵树。
2. ==**邻接表法**==
	 // 1 -> {2, 3}
	 // 2 -> {4}
	 // 3 -> {5, 6}
	 unordered_map<int, vector<int>> tree;
		 1. key:int；父亲
		 2. Value：vector<int>;孩子列表，不止一个孩子vector。
	 tree[1] = {2, 3};
	 tree[2] = {4};
	 tree[3] = {5, 6};
# 二叉树的递归/层序遍历
![[Pasted image 20251210191606.png]] 

## 递归遍历
void traverse(TreeNode* root) {
    if (root == nullptr) {    如果前面没路了（空节点），立刻停下，退回上一个路口。这是防止死循环和程序崩溃的安全网。
        return;
    // 【插槽 1：前序位置】 
    // 时机：刚刚进入这个节点，还没去探索子节点。
	// 类似于：作为领导，先发表讲话，再让手下去干活。
	 // 代码放这里 -> 前序遍历 (Pre-Order)
    }
    traverse(root->left);**先去左边探险**：不管三七二十一，先往左边的岔路口走到底
    // 【插槽 2：中序位置】
     // 时机：刚刚从左子树探索回来，还没去右子树。
	 // 类似于：左边的活干完了，回来汇报一下，然后去右边干活。 
	 // 代码放这里 -> 中序遍历 (In-Order)
    traverse(root->right);**再去右边探险**：左边走完了，退回来，再去右边的岔路口走到底。
    // 【插槽 3：后序位置】
     // 时机：左右两边的子树都探索完了，准备离开这个节点返回上级。
	// 类似于：手下把活全干完了，领导最后做总结汇报。
    // 代码放这里 -> 后序遍历 (Post-Order)
}
案例 A：打印整棵树 (Pre-order)
	cout << root->val; // 填在 traverse(left) 之前
	traverse(root->left);
	traverse(root->right);
案例 B：销毁整棵树 (Post-order)
	traverse(root->left);
	traverse(root->right);
	delete root; // 填在最后，确保孩子都死光了，自己再死
案例 C：倒序打印 BST (In-order 变体)
	traverse(root->right); // 先去右边（找大的）
	cout << root->val;     // 中间打印
	traverse(root->left);  // 后去左边（找小的）
## 层序遍历
![[Pasted image 20251210194157.png]] 
### 写法一
void levelOrderTraverse(TreeNode* root) {
    if (root == nullptr) {
        return;==如果没有根，直接收工回家，没有客户。==
    }
    std::queue<TreeNode*> q;==初始化队列（节点组成）==
    q.push(root);==放入第一个老祖；==
    while (!q.empty()) {            ==只要有人就不能下班==
        TreeNode* cur = q.front();==当前接受处理的人==
        q.pop();==让他出队==
        // 访问 cur 节点
        std::cout << cur->val << std::endl;==办完事总结==
        
        // 把 cur 的左右子节点加入队列
        if (cur->left != nullptr) {
            q.push(cur->left);==先把左边的娃叫一下==
        }
        if (cur->right != nullptr) {
            q.push(cur->right);==再把右边的娃叫一下==
        }
    }
}
### 写法二：加入了深度也就是几层
void levelOrderTraverse(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
    queue<TreeNode*> q;
    q.push(root);
    // 记录当前遍历到的层数（根节点视为第 1 层）
    int depth = 1;

    while (!q.empty()) {
        int sz = q.size();
        for (int i = 0; i < sz; i++) {
            TreeNode* cur = q.front();
            q.pop();
            // 访问 cur 节点，同时知道它所在的层数
            cout << "depth = " << depth << ", val = " << cur->val << endl;

            // 把 cur 的左右子节点加入队列
            if (cur->left != nullptr) {
                q.push(cur->left);
            }
            if (cur->right != nullptr) {
                q.push(cur->right);
            }
        }
        depth++;
    }
}
== for循环的i就类似cur，表示我指到第几层的第几个了==
### 写法三
class State {
public:
    TreeNode* node;
    int depth;

    State(TreeNode* node, int depth) : node(node), depth(depth) {}
};

void levelOrderTraverse(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
    queue<State> q;
    // 根节点的路径权重和是 1
    q.push(State(root, 1));

    while (!q.empty()) {
        State cur = q.front();
        q.pop();
        // 访问 cur 节点，同时知道它的路径权重和
        cout << "depth = " << cur.depth << ", val = " << cur.node->val << endl;

        // 把 cur 的左右子节点加入队列
        if (cur.node->left != nullptr) {
            q.push(State(cur.node->left, cur.depth + 1));
        }
        if (cur.node->right != nullptr) {
            q.push(State(cur.node->right, cur.depth + 1));
        }
    }
}