# 第12章：链表与位运算 (Bitwise)

## 1. 位运算 (Bitwise Operations) —— 嵌入式基石

直接对二进制位进行操作。

| 运算符 | 描述 | 例子 |
| :--- | :--- | :--- |
| `&` | 按位与 (AND) | `1010 & 1100 = 1000` |
| `|` | 按位或 (OR) | `1010 | 1100 = 1110` |
| `^` | 按位异或 (XOR)| `1010 ^ 1100 = 0110` |
| `~` | 按位取反 (NOT)| `~00001010 = 11110101` |
| `<<` | 左移 | `1 << 2` (1变成100，即4) |
| `>>` | 右移 | `8 >> 2` (1000变成10，即2) |

### 常用技巧 (寄存器操作)
假设 `REG` 是一个 8 位的寄存器。

1.  **置位 (Set Bit)**：将第 n 位置 1。
    ```c
    REG |= (1 << n);
    ```
2.  **清零 (Clear Bit)**：将第 n 位置 0。
    ```c
    REG &= ~(1 << n);
    ```
3.  **翻转 (Toggle Bit)**：将第 n 位取反。
    ```c
    REG ^= (1 << n);
    ```
4.  **检查位**：检查第 n 位是不是 1。
    ```c
    if (REG & (1 << n)) { ... }
    ```

## 2. 动态内存分配 (malloc/free)

在堆 (Heap) 上申请内存。

```c
#include <stdlib.h>

int *p = (int *)malloc(sizeof(int) * 10); // 申请 10 个 int 的空间
if (p != NULL) {
    // 使用内存...
    free(p); // 必须释放！否则内存泄漏 (Memory Leak)
    p = NULL; //以此避免野指针
}
```
**嵌入式慎用**：在资源受限的单片机中，频繁 `malloc/free` 会导致内存碎片，通常推荐使用静态数组或内存池。

## 3. 链表 (Linked List)

一种动态数据结构，每个节点包含数据和指向下一个节点的指针。

```c
struct Node {
    int data;
    struct Node *next;
};

// 遍历链表
void print_list(struct Node *head) {
    struct Node *current = head;
    while (current != NULL) {
        printf("%d -> ", current->data);
        current = current->next;
    }
    printf("NULL\n");
}
```
链表在操作系统（如 FreeRTOS）的任务管理中无处不在。

