# 第6章：函数 (Functions)

## 1. 为什么需要函数？ (Why Functions?)

在编程中，函数主要有两个作用：
1.  **代码复用**：将常用的代码逻辑封装起来，避免重复编写。
2.  **分而治之**：将复杂的任务分解为一个个小的、易于管理的模块（函数）。

翁恺老师常把函数比作一个**“黑盒”**：你只需要知道它**接收什么**（参数），以及它**产出什么**（返回值），而不需要时刻关心它内部具体是如何实现的。

## 2. 函数的定义与调用

### 2.1 ==基本语法==

```c
// 返回类型 函数名 (参数列表)
// {
//     函数体
// }

int max(int a, int b) {
    if (a > b) {
        return a;
    } else {
        return b;
    }
}
```

*   **返回类型**：函数执行完毕后==返回给调用者的数据类型==（如 `int`, `float`, `void`）。
*   **函数名**：调用函数时使用的标识符。
*   **参数列表**：传递给函数的数据。可以没有参数，也可以有多个。
*   **函数体**：大括号 `{}` 内的代码块，实现具体功能。

### 2.2 函数的调用

```c
int main() {
    int m = max(10, 20); // 调用 max 函数，将结果赋值给 m
    printf("最大值是: %d\n", m);
    return 0;
}
```

## 3. 函数的声明 (Declaration) / 原型 (Prototype)

C 编译器是自上而下分析代码的。如果函数定义在 `main` 函数之后，编译器在读到 `main` 调用该函数时，会因为不认识这个函数而报错（或给出警告并进行隐式声明，这很危险）。

为了解决这个问题，我们需要在调用前进行**函数声明**（也称函数原型）。

```c
#include <stdio.h>

// 1. 函数声明 (告诉编译器：有一个叫 add 的函数，接收两个 int，返回一个 int)
// 注意：声明结尾必须有分号
int add(int a, int b); 

int main() {
    int sum = add(3, 5); // 编译器现在认识 add 了
    printf("%d\n", sum);
    return 0;
}

// 2. 函数定义 (具体的实现)
int add(int a, int b) {
    return a + b;
}
```

> **翁恺老师提示**：
> 即使不写参数名（如 `int add(int, int);`）也是合法的，但为了代码可读性，建议保留参数名。

## 4. 参数传递 (Pass by Value) —— 核心概念

**在 C 语言中，函数参数的传递永远是“传值”的。**

这意味着：函数接收到的，永远是调用者传递进来的变量的**一份拷贝**。

### 4.1 传值示例

```c
void swap(int a, int b) {
    int temp = a;
    a = b;
    b = temp;
    printf("在函数内部: a=%d, b=%d\n", a, b); // 这里确实交换了
}

int main() {
    int x = 10;
    int y = 20;
    swap(x, y);
    printf("在 main 中: x=%d, y=%d\n", x, y); // 输出 x=10, y=20 (没变！)
    return 0;
}
```

**解析**：`x` 和 `y` 的值被复制给了 `swap` 函数的参数 `a` 和 `b`。`swap` 里的交换操作只是在交换这两份**副本**，原本的 `x` 和 `y` 毫发无损。

### 4.2 参数列表的细节

*   **`void f(void)` vs `void f()`**：
    *   `void f(void)`：明确表示该函数**不接收任何参数**。如果调用时传参，编译器会报错。
    *   `void f()`：在传统 C 语言中，表示参数**未知**（不是没有）。编译器不会检查参数类型和个数，这可能导致潜在的 Bug。**建议始终使用 `void f(void)` 来表示无参函数。**

## 5. 本地变量 (Local Variables)

在函数内部（包括 `main` 函数）定义的变量，称为本地变量。

*   **生存期 (Lifetime)**：
    *   进入函数（或代码块）时创建。
    *   离开函数（或代码块）时销毁。
*   **作用域 (Scope)**：
    *   仅在当前的大括号 `{}` 块内有效。
*   **存储位置**：
    *   通常存储在**栈 (Stack)** 中。
*   **初始化**：
    *   **重要**：本地变量如果没有显式初始化，它的值是**随机的垃圾值**（上次遗留在内存里的内容），而不是 0。

## 6. 其他变量类型 (Advanced)

除了本地变量，C 语言还有其他类型的变量：

### 6.1 全局变量 (Global Variables)

定义在所有函数之外的变量。
*   **作用域**：从定义位置开始，整个程序（所有文件）都可以访问（需要 extern 声明）。
*   **生存期**：程序运行期间一直存在。
*   **初始化**：如果没有显式初始化，**默认被初始化为 0**。
*   **弊端**：全局变量破坏了函数的“独立性”和“黑盒”特性，使得代码难以维护和调试。**在嵌入式开发中应谨慎使用。**

### 6.2 静态本地变量 (Static Local Variables)

在函数内部使用 `static` 关键字定义的变量。
*   **特殊性**：它虽然是本地变量（只能在函数内访问），但它具有**全局生存期**。
*   **效果**：函数结束时，它**不会**被销毁；下一次调用该函数时，它**依然保持**上一次修改后的值。
*   **初始化**：只在第一次进入函数时初始化一次。默认为 0。

```c
void count_calls() {
    static int count = 0; // 静态本地变量
    count++;
    printf("函数被调用了 %d 次\n", count);
}

int main() {
    count_calls(); // 输出 1
    count_calls(); // 输出 2
    count_calls(); // 输出 3
}
```

## 7. 嵌入式中的函数注意事项

1.  **栈溢出 (Stack Overflow)**：
    *   嵌入式芯片的 RAM 资源极其有限（栈空间可能仅 1KB~4KB）。
    *   **切忌**在函数内部定义巨大的数组（如 `int buffer[4096]`），这会瞬间耗尽栈空间，导致程序崩溃或系统复位。
    *   大数组应定义为全局变量，或使用 `static` 修饰。

2.  **避免递归 (Avoid Recursion)**：
    *   递归调用会不断压栈。由于无法精确控制递归深度，极易引发栈溢出。在嵌入式标准（如 MISRA C）中，通常禁止使用递归。

3.  **内联函数 (Inline Functions)**：
    *   对于非常短小且频繁调用的函数，可以考虑使用 `inline` 关键字（C99 标准），建议编译器将函数代码直接展开到调用处，省去函数调用的开销（压栈、跳转），换取速度（但会增加代码体积）。

```