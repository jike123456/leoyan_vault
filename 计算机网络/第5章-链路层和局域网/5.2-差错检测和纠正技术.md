# 5.2 差错检测和纠正技术

数据在物理链路上传输时，可能会因为信号衰减或电磁噪声等原因，导致比特发生翻转（即0变成1，或1变成0）。为了应对这种情况，链路层协议需要在帧中加入额外的**冗余比特**，以实现差错的检测和纠正。

---

### 1. 奇偶校验 (Parity Checks)

这是最简单的一种差错检测技术。

*   **单比特奇偶校验**:
    *   **工作原理**: 发送方在要发送的数据（d个比特）后附加一个**奇偶校验位**。
        *   **偶校验**: 设置校验位，使得整个数据（d+1个比特）中“1”的个数为偶数。
        *   **奇校验**: 设置校验位，使得整个数据中“1”的个数为奇数。
    *   **接收方**: 计算接收到的d+1个比特中“1”的个数。如果使用偶校验，但“1”的个数是奇数，则说明发生了错误。
    *   **缺点**:
        *   只能检测出**奇数个**比特的错误。如果同时有两个比特发生翻转，奇偶性不变，就无法检测出错误。
        *   无法纠正错误。

*   **二维奇偶校验**:
    *   **工作原理**: 将数据比特排成一个二维矩阵。对每一行和每一列都进行单比特奇偶校验。
    *   **优点**: 不仅可以检测出错误，还能在一定程度上**定位并纠正单个比特**的错误。如果某一行和某一列的奇偶校验都不匹配，那么它们的交叉点就是出错的比特位。
    *   **缺点**: 开销较大，且对于多个比特错误仍然无能为力。

---

### 2. 校验和 (Checksumming)

校验和主要应用于网络的上层（如运输层和网络层），但其原理同样适用于链路层。

*   **工作原理 (因特网校验和)**:
    1.  **发送方**: 将要传输的数据划分为一系列16比特的整数。
    2.  将所有这些整数相加（使用16位的反码算术，即高位溢出要加到低位上）。
    3.  对最终的和按位取反，得到的结果就是**校验和**。
    4.  发送方将这个校验和放在帧的相应字段中。
*   **接收方**:
    1.  将接收到的所有16比特字（包括校验和本身）相加。
    2.  如果结果的所有比特位都是1（即 `-0`），则认为没有检测到差错。
*   **优点**: 比奇偶校验的检错能力更强。
*   **缺点**: 仍然不是绝对可靠的，某些特定的多比特错误可能碰巧相互抵消，导致校验和结果正确。

---

### 3. 循环冗余检测 (Cyclic Redundancy Check, CRC)

CRC是一种功能非常强大且应用广泛的差错检测技术，被以太网、WiFi等多种现代链路层协议所采用。

*   **核心思想**: 将要传输的数据比特串，看作是一个高次多项式的系数。然后通过多项式运算，来计算出差错检测码。
*   **工作原理**:
    1.  **生成多项式 (Generator Polynomial)**: 发送方和接收方预先约定一个r+1比特的生成多项式 `G`。
    2.  **发送方**:
        *   在要发送的d比特数据 `D` 后面附加r个0。
        *   用 `G` 去“除”这个新的 `D·2^r` 比特串（使用模2算术，即异或运算）。
        *   得到的**余数** `R`（r个比特）就是CRC校验码。
        *   将这个余数 `R` 附加到原始数据 `D` 的末尾，形成 `D+R` 并发送。
    3.  **接收方**:
        *   用相同的生成多项式 `G` 去“除”接收到的 `D+R` 比特串。
        *   **如果余数为0**，则认为传输没有差错。
        *   **如果余数不为0**，则说明在传输过程中发生了错误，接收方会丢弃该帧。
*   **优点**:
    *   **检错能力极强**: 能够检测出所有小于等于r的突发错误（即连续的r个比特错误）、所有奇数个比特的错误，以及绝大多数其他类型的错误。
    *   硬件实现简单高效。
*   **类比**: CRC就像一种非常精巧的“数学指纹”。原始数据经过生成多项式运算后，会得到一个独特的“指纹”（余数）。接收方用同样的方法计算接收到的数据的“指纹”，如果两个“指纹”匹配（即余数为0），就说明数据在传输过程中没有被篡改。
