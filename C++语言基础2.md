1. 双链表初始化
	1. std:: list<int> lst; //初始化一个空的双向链表
	2. std:: list<int> lst(n); //初始化一个大小为n的值为0的双向链表lst
	3. std:: list<int> lst{1, 3, 5};//初始化值为1，3，5的双向链表lst，***==初始化为{}==***
	4. std:: list<int> lst(n, 2);//初始化值全为2
2. 双链表常用方法
	1. cout << lst.empty() << endl;
	2. cout << lst.size() << endl;
	3. lst.push_front(0); //链表头部插入元素0
	4. lst.push_back(100);// 链表尾部插入元素100
	5. cout << lst.front() << " "<< lst.back() << endl;//看链表头部以及尾部元素
	6. lst.pop_front(); lst.pop_back(); //链表弹出头部与尾部
	7. auto it = lst.begin()；//auto自动判断it的类型；begin完更好操作
	 advance(it,2);//往前移动两位，相当移动到第三个元素
	 lst.insert(it, 99);//第三个元素插入为99。
	8. auto it = lst.begin();
	   advance(it, 1);
	   lst.erase(==it==);
	9. for(int val : lst){
		   cout << val << " ";
	   }
	   cout << endl;
	10. 头部增减元素使用链表
3. 队列；先进先出；只允许从**队尾**添加元素，从**队头**弹出元素
	  1. queue<int> q;//初始化一个空队列
	  2. q.push(1);//队尾添加元素
	  3. cout << q.empty() <<endl;
	  4. cout << q.size() << endl;
	  5. cout << q.front() << q.back() << endl;
	  6. q.pop();
4. stack栈：后进先出；只允许栈顶添加或者弹出元素；
	1. stack <int> s;
	2. s.push(1);//栈顶添加元素
	3. s.empty();
	4. s.size();
	5. s.top()
	6. s.pop()
5. unordered_map哈希表；键值对（key-value）
	1. unordered_map<int, string> hashmap;//初始化一个哈希表
	2. unordered_map<int, string> hashmap{{1,"one"}, {2,"two"}, {3, "three"}};//键值对的哈希表，注意==大括号==，都是大括号
	3. 哈希表访问不存在的键会自动插入==新键对==
	4. cout << hashmap.empty() << endl;
	5. cout << hashmap.size() << endl;
	6. 查找指定键是否存在
		if(hashmap.contains(2)){
			cout << "Key 2 - > " << hashmap[2] <<endl;
		} else{
			cout << "Key 2 not found. " <<endl;
		}
	7. cout << hashmap[4] << endl;//不存在会返回默认构造的值
	8. hashmap[4] = "four"; //插入键值对
	   cout << hashmap[4] << endl;//获取一个新的键值对。
	9. hashmap.erase(3);//删除键值对
	10. 删除键3后是否存在
		if (hashmap.contain(3)){
			cout << "Key 3 -> " << hashmap[3] << endl;
		} else{
			cout << "Key 3 not found. " << endl;
		}
	11. 遍历哈希表
		for (const auto &pair: hashmap) {
			cout << pair.first <<"->"<< pair.second << endl;
		} // const auto&:以常量引用方式获取元素；pair.first:键；pair.second: 值
	12. 访问不存在的键会自动创键，值为默认构造值
		unordered_map<int, string> hashmap2;
		cout << hashmap2.size() << endl;输出为0
		cout << hashmap2[1] <<endl;创造新键1
		cout <<hashmap2[2] << endl;创造新键2
		cout << hashmap.size() << endl;//输出为2
 6. 传值：传的只是值，不修改num，修改x；而非内存地址
	 1. void modifyValue(int x) {
	    x = 10;
	   }//没有加上&，他会变，下面不会
	 2. int main{
		 int num = 5;
		 modifyValue(num);//输出5
		  cout << "After modifyValue, num = " << num << endl;
	   }
7. 传引用：引用的实则是地址，函数也就可以操作原始数据
	1. void modifyReference(int &x){
		 x = 10;
	 }
	 2. int main() {
		 int num = 5;
		 modifyReference(num) ;
		 cout << "After modifyReference, num = " << num << endl;
	  }
8. 传值的基本类型也就是int、bool，不需要在函数内部进行修改
   传引用一般传递容器数据结构，vector、unordered_map比较多，避免复制的开销，容器一般要在内部进行修改