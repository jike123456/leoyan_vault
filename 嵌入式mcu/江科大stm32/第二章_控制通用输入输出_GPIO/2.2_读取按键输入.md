# 2.2 读取按键输入

## 1. 硬件连接与模式选择

*   **硬件连接**：通常按键一端接 GPIO，另一端接 **GND**。
*   **按键按下**：引脚直接接地，读取到 **低电平 (0)**。
*   **按键松开**：引脚悬空。为了保证电平稳定，必须配置为 **上拉输入 (IPU)**，使悬空时默认被拉高到 **高电平 (1)**。

## 2. 按键抖动与消抖

机械按键在闭合和断开瞬间，触点会发生弹性碰撞，导致电平在 5~10ms 内剧烈抖动。
如果不处理，按下一次可能会被误读为多次。

*   **硬件消抖**：并联电容（0.1uF），利用充放电延时平滑波形。
*   **软件消抖**：检测到按下后，延时 10~20ms，再次检测。

## 3. 按键扫描代码实现

通常将按键封装为 `Key.c` 模块。

### 初始化 (Key_Init)

```c
void Key_Init(void)
{
    // 1. 开启 GPIOB 时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
    
    // 2. 配置 PB1 和 PB11 为上拉输入
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_11;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; // 上拉输入，非常重要！
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOB, &GPIO_InitStructure);
}
```

### 读取键值 (Key_GetNum)

```c
uint8_t Key_GetNum(void)
{
    uint8_t KeyNum = 0;
    
    // 检测按键 1 (PB1)
    if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == 0) // 读到低电平表示按下
    {
        Delay_ms(20); // 1. 前消抖
        while (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == 0); // 2. 等待按键松开 (死循环等待)
        Delay_ms(20); // 3. 后消抖
        KeyNum = 1;
    }
    
    // 检测按键 2 (PB11)
    if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_11) == 0)
    {
        Delay_ms(20);
        while (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_11) == 0);
        Delay_ms(20);
        KeyNum = 2;
    }
    
    return KeyNum; // 返回键码，0表示无按键
}
```

## 4. 注意事项

1.  **浮空输入风险**：如果配置为 `GPIO_Mode_IN_FLOATING`，按键松开时引脚电平会随机跳变，导致程序误触发。必须配合外部上拉电阻或改用内部上拉。
2.  **死循环等待**：上述代码中的 `while` 会阻塞主循环。在实时性要求高的系统中，建议使用定时器中断轮询法代替延时阻塞。