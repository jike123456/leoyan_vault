# 7.2 模拟 I2C 通信 (MPU6050)

## 1. 软件模拟 I2C 的优势
*   **引脚灵活**：任意两个 GPIO 都能模拟 SCL 和 SDA。
*   **稳定性好**：STM32F1 的硬件 I2C 存在设计瑕疵（容易卡死），工程中常用软件模拟。
*   **配置**：SCL 和 SDA 均配置为 **推挽输出**（如果不加外部上拉）或 **开漏输出**（标准 I2C，需外部上拉）。江科大代码中为了方便，通常用推挽输出模拟。

## 2. 时序单元实现

定义宏操作引脚：
`#define MyI2C_W_SCL(x) GPIO_WriteBit(..., x)`

*   **起始条件 (Start)**：SCL 高电平期间，SDA 从高变低。
*   **终止条件 (Stop)**：SCL 高电平期间，SDA 从低变高。
*   **发送字节 (SendByte)**：
    *   SCL 拉低，SDA 放置数据位 (0/1)。
    *   SCL 拉高（从机读取）。
    *   SCL 拉低。
    *   循环 8 次。
*   **接收应答 (ReceiveAck)**：
    *   主机释放 SDA (置1)。
    *   SCL 拉高，读取 SDA 电平（0 表示应答 ACK，1 表示非应答 NACK）。
    *   SCL 拉低。

## 3. MPU6050 操作

*   **设备地址**：`0xD0` (AD0 接地)。
*   **写寄存器**：
    Start -> 发送从机地址(写) -> 接收ACK -> 发送寄存器地址 -> 接收ACK -> 发送数据 -> 接收ACK -> Stop。
*   **读寄存器**：
    Start -> 发送从机地址(写) -> ACK -> 发送寄存器地址 -> ACK -> **ReStart** -> 发送从机地址(读) -> ACK -> 读取数据 -> 发送NACK -> Stop。

### 关键代码 (写寄存器)
```c
void MPU6050_WriteReg(uint8_t RegAddress, uint8_t Data)
{
    MyI2C_Start();
    MyI2C_SendByte(0xD0); // 写地址
    MyI2C_ReceiveAck();
    MyI2C_SendByte(RegAddress);
    MyI2C_ReceiveAck();
    MyI2C_SendByte(Data);
    MyI2C_ReceiveAck();
    MyI2C_Stop();
}
```