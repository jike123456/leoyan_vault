# 7.1 实现串口通信 (UART)

## 1. 协议基础

*   **物理层**：TX (发送), RX (接收), GND (共地)。
    *   **TTL 电平**：3.3V/5V 表示逻辑1，0V 表示逻辑0（单片机直连）。
    *   **RS232 电平**：-15V 表示逻辑1，+15V 表示逻辑0（需 MAX3232 转换）。
*   **数据帧**：通常配置为 **9600-8-N-1**
    *   波特率：9600 bps。
    *   数据位：8位。
    *   校验位：无 (None)。
    *   停止位：1位。

## 2. 串口初始化 (USART1)

```c
// 1. 开启时钟 (USART1 在 APB2)
RCC_APB2PeriphClockCmd(RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA, ENABLE);

// 2. 配置 GPIO
// TX (PA9): 复用推挽输出
GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
GPIO_Init(GPIOA, &GPIO_InitStructure);
// RX (PA10): 浮空输入或上拉输入
GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
GPIO_Init(GPIOA, &GPIO_InitStructure);

// 3. 配置 USART
USART_InitTypeDef USART_InitStructure;
USART_InitStructure.USART_BaudRate = 9600;
USART_InitStructure.USART_WordLength = USART_WordLength_8b;
USART_InitStructure.USART_StopBits = USART_StopBits_1;
USART_InitStructure.USART_Parity = USART_Parity_No;
USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;
USART_Init(USART1, &USART_InitStructure);

// 4. 开启中断 (如果要用中断接收)
USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
NVIC_Init(...); // 配置 USART1_IRQn

// 5. 启动
USART_Cmd(USART1, ENABLE);
```

## 3. 发送数据与 printf 重定向

### 发送单字节
```c
void Serial_SendByte(uint8_t Byte)
{
    USART_SendData(USART1, Byte);
    // 等待 TXE (Transmit Data Register Empty) 标志位置 1
    while (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);
}
```

### printf 重定向
在 MicroLIB 勾选的情况下，重写 `fputc` 函数：
```c
#include <stdio.h>

int fputc(int ch, FILE *f)
{
    Serial_SendByte(ch);
    return ch;
}
// 使用：printf("Temp = %d\n", temp);
```

## 4. 接收数据包 (状态机法)

设计一个“包头(0xFF) + 数据 + 包尾(0xFE)”的协议。
在中断 `USART1_IRQHandler` 中：

```c
void USART1_IRQHandler(void)
{
    if (USART_GetITStatus(USART1, USART_IT_RXNE) == SET)
    {
        uint8_t RxData = USART_ReceiveData(USART1);
        
        // 简单状态机
        if (State == 0) // 等待包头
        {
            if (RxData == 0xFF) State = 1;
        }
        else if (State == 1) // 接收数据
        {
            Data[Index++] = RxData;
            if (Index >= 4) State = 2; // 假设数据长4
        }
        else if (State == 2) // 等待包尾
        {
            if (RxData == 0xFE) { /* 处理数据 */ State = 0; Index = 0; }
        }
        
        USART_ClearITPendingBit(USART1, USART_IT_RXNE);
    }
}
```