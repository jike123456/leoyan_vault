1. 他仅仅是一个标记头的地方，遍历必须用其他==cur==来代替，不然就会丢失头节点，导致整个链表找不到了
2. 回收机制：tmp（==临时记住==，用完就删除）与cur；
`ListNode* temp = cur; cur = cur->next; delete tmp;`
3. 要删除的话必须知道他的上一个指针是什么，有点像递归了
# 虚拟头节点的语法
```
ListNode* dummy = new ListNode(0);
```
# 为什么把虚拟头节点赋给其他指针
```
ListNode* dummy = new ListNode(-1); // 1. 造钉子（定坐标）
dummy->next = head;                 
ListNode* p = dummy;  只是复制不改变dummy              // 2. 伸手（造干活的替身）
```
把其他指针当成干活跑腿的；自己守家，不然家就没了
# 为什么要设立一个虚拟头节点
要逻辑保持一致
- 没有虚拟头节点
	- **如果要拆第 3 节车厢：** 很简单，你站在第 2 节车厢，把连接钩断开，连到第 4 节去。
	- **如果要拆第 1 节车厢（车头）：** 麻烦大了！因为第 1 节前面没有车厢，你没法站在“前一节”去操作。你需要一套**完全不同**的动作：把“火车头”的标志从第 1 节挪到第 2 节。
	- cpp示例
		```
		if (head->val == target) { // 哎呀，要删的是头节点
		    head = head->next;     // 特殊处理
		} else {
		    // 处理普通节点...
		}
		```
- 有虚拟头节点
	-  **如果要拆第 1 节（真正的头）：** 现在它变成了“假车头”的下一节。你站在“假车头”上，把钩子连到第 2 节。
	- **如果要拆第 3 节：** 你站在第 2 节上，把钩子连到第 4 节。
	- cpp示例
		```
		// 🌟 推荐写法：使用虚拟头节点
		ListNode* dummy = new ListNode(0); // 造一个假人
		dummy->next = head;                // 假人站在排头，抓住原来的老大
		
		ListNode* cur = dummy;             // 我们从假人开始遍历
		while (cur->next != NULL) {
		    if (cur->next->val == target) {
		        cur->next = cur->next->next; // 统一的操作逻辑
		    } else {
		        cur = cur->next;
		    }
		}
		return dummy->next; //哪怕原来的老大被删了，dummy->next 永远指向现在的真老大
		```
