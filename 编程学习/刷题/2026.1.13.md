## 226.翻转二叉树
### 递归法
```cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == NULL) return root;
        swap(root->left, root->right);  // 中
        invertTree(root->left);         // 左
        invertTree(root->right);        // 右
        return root;
    }
};
```

root因为返回不为空。root也是先回到没执行的部分。

### 迭代法
深度优先遍历

```cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == NULL) return root;
        stack<TreeNode*> st;
        st.push(root);
        while(!st.empty()) {
            TreeNode* node = st.top();              // 中
            st.pop();
            swap(node->left, node->right);
            if(node->right) st.push(node->right);   // 右
            if(node->left) st.push(node->left);     // 左
        }
        return root;
    }
};
```
基于stack的先进后出的性质，先右后左

广度优先遍历（层序遍历）队列
```cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        while (!que.empty()) {
            int size = que.size();
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                swap(node->left, node->right); // 节点处理
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
        }
        return root;
    }
};
```
## 对称二叉树
思路：分为左右子树，一侧左右中，一侧右左中

递归法

 1. 确定递归的参数与返回值：参数就是左右节点，返回值则是bool
 2. 确定终止条件：左空右不空，右空左不空，左右都空，左右不等。
 3. 确定单层递归逻辑：
### demo
```cpp
class Solution {
public:
    bool compare(TreeNode* left, TreeNode* right) {
        if (left == NULL && right != NULL) return false;
        else if (left != NULL && right == NULL) return false;
        else if (left == NULL && right == NULL) return true;
        else if (left->val != right->val) return false;
        else return compare(left->left, right->right) && compare(left->right, right->left);

    }
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        return compare(root->left, root->right);
    }
};
```

## 104.二叉树的最大深度
### 递归法（后序遍历）
![500](assets/2026.1.13/file-20260113171116779.png)
#### **第一阶段：从根节点 3 开始向下探索**

- **`getdepth(3)` 被调用**
    
    - 3 不为空。
        
    - 准备计算 3 的左深度：调用 `getdepth(9)`
        
        - **`getdepth(9)` 被调用**
            
            - 准备计算 9 的左深度：调用 `getdepth(1)`
                
                - **`getdepth(1)` 被调用**
                    
                    - 准备计算 1 的左深度：调用 `getdepth(7)`
                        
                        - **`getdepth(7)` 被调用**
                            
                            - 7 的左边是 NULL -> 返回 0
                                
                            - 7 的右边是 NULL -> 返回 0
                                
                            - **7 汇报**：`1 + max(0, 0) = 1`。**(7的深度是1)**
                                
                        - **`getdepth(7)` 返回 1**。
                            
                    - (回到节点 1) 刚才算出了左边是 1。
                        
                    - 准备计算 1 的右深度：1 的右孩子是 NULL -> 返回 0。
                        
                    - **1 汇报**：`1 + max(1, 0) = 2`。**(1的深度是2)**
                        
                - **`getdepth(1)` 返回 2**。
                    
            - (回到节点 9) 刚才算出了左边是 2。
                
            - 准备计算 9 的右深度：调用 `getdepth(2)`
                
                - **`getdepth(2)` 被调用** (它是叶子)
                    
                    - 左右都是 0。
                        
                    - **2 汇报**：`1 + max(0, 0) = 1`。**(2的深度是1)**
                        
                - **`getdepth(2)` 返回 1**。
                    
            - (回到节点 9) 现在数据齐了：左边深度 2 (来自节点1)，右边深度 1 (来自节点2)。
                
            - **9 汇报**：`1 + max(2, 1) = 3`。**(9的深度是3)**
                
        - **`getdepth(9)` 返回 3**。
            
    - (回到根节点 3) **此时，左边的任务全部结束，Root 知道左边深度是 3。**
        
    - 现在开始计算 3 的右深度：调用 `getdepth(20)`
#### **第二阶段：处理右子树 20**

* **`getdepth(20)` 被调用**
    * 准备计算 20 的左深度：调用 `getdepth(5)`
        * **`getdepth(5)` 被调用** (它是叶子)
            * **5 汇报**：`1 + max(0, 0) = 1`。
        * **`getdepth(5)` 返回 1**。
    * 准备计算 20 的右深度：调用 `getdepth(6)`
        * **`getdepth(6)` 被调用** (它是叶子)
            * **6 汇报**：`1 + max(0, 0) = 1`。
        * **`getdepth(6)` 返回 1**。
    * (回到节点 20) 数据齐了：左边 1，右边 1。
    * **20 汇报**：`1 + max(1, 1) = 2`。**(20的深度是2)**
* **`getdepth(20)` 返回 2**。

#### **第三阶段：根节点汇总**

- (回到根节点 3)
    
    - `leftdepth` (左边的结果) = **3** (这是因为有 9->1->7 这条长线)
        
    - `rightdepth` (右边的结果) = **2**
        
- **最终计算**：
    
    - `depth = 1 + max(3, 2)`
        
    - `depth = 1 + 3`
        
    - `depth = 4`
        
- **返回 4**。

不要试图在脑子里同时模拟整棵树。**只关注当前节点和它的直接下级。** 当你站在 **节点 9** 的时候，你不要管 **7** 是怎么算的。你只管命令 **节点 1** 去干活。**节点 1** 怎么算出来是它自己的事，你只要拿到它返回的 **2** 就可以了。

#### demo
```cpp
class Solution {
public:
    int getdepth(TreeNode* node) {
        if (node == NULL) return 0;
        int leftdepth = getdepth(node->left);       // 左
        int rightdepth = getdepth(node->right);     // 右
        int depth = 1 + max(leftdepth, rightdepth); // 中
        return depth;
    }
    int maxDepth(TreeNode* root) {
        return getdepth(root);
    }
};
```

### 层序遍历
#### demo
```cpp
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (root == NULL) return 0;
        int depth = 0;
        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty()) {
            int size = que.size();
            depth++; // 记录深度
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
        }
        return depth;
    }
};
```
`if (root == NULL) return 0;` 更好，先处理空节点；并且如果是空，不会创建空节点。

## 559.n叉树的最大深度
### 递归法
```cpp
class Solution {
public:
    int maxDepth(Node* root) {
        if (root == 0) return 0;
        int depth = 0;
        for (int i = 0; i < root->children.size(); i++) {
            depth = max (depth, maxDepth(root->children[i]));
        }
        return depth + 1;
    }
};
```
牢记三步法
1. 确定你的参数与返回值
2. 每一层干什么
3. 截止的条件是什么。

### 迭代法（层序遍历）
