## 110.平衡二叉树

### 递归法

```cpp
class Solution {
public:
    // 返回以该节点为根节点的二叉树的高度，如果不是平衡二叉树了则返回-1
    int getHeight(TreeNode* node) {
        if (node == NULL) {
            return 0;
        }
        int leftHeight = getHeight(node->left);
        if (leftHeight == -1) return -1;
        int rightHeight = getHeight(node->right);
        if (rightHeight == -1) return -1;
        return abs(leftHeight - rightHeight) > 1 ? -1 : 1 + max(leftHeight, rightHeight);
    }
    bool isBalanced(TreeNode* root) {
        return getHeight(root) == -1 ? false : true;
    }
};
```
图例

![500](assets/2026.1.14/file-20260114120525948.png)

#### 逐层计算高度表：

| **节点**      | **左子树高度**    | **右子树高度**    | **差值** | **是否平衡？** | **返回给父节点的值** |
| ----------- | ------------ | ------------ | ------ | --------- | ------------ |
| **Node 4**  | 0            | 0            | 0      | 是         | **1**        |
| **Node 3L** | 1 (来自N4)     | 1 (来自N4)     | 0      | 是         | **2**        |
| **Node 3R** | 0            | 0            | 0      | 是         | **1**        |
| **Node 2L** | 2 (来自3L)     | 1 (来自3R)     | **1**  | **是**     | **3**        |
| **Node 2R** | 0            | 0            | 0      | 是         | **1**        |
| **Node 1**  | **3** (来自2L) | **1** (来自2R) | **2**  | **否！**    | **-1**       |
**关键词**：

1. **逐层上报高度**
    
2. **差值阈值 1**
    
3. **根节点定胜负**（把自己当根）局部思维

## 257.二叉树的所有路径

### 思路

前序排序；要的是路径
string sPath;定义的位置不能在for
```cpp
class Solution {
private:

    void traversal(TreeNode* cur, vector<int>& path, vector<string>& result) {
        path.push_back(cur->val); // 中，中为什么写在这里，因为最后一个节点也要加入到path中 
        // 这才到了叶子节点
        if (cur->left == NULL && cur->right == NULL) {
            string sPath;
            for (int i = 0; i < path.size() - 1; i++) {
                sPath += to_string(path[i]);
                sPath += "->";
            }
            sPath += to_string(path[path.size() - 1]);
            result.push_back(sPath);
            return;
        }
        if (cur->left) { // 左 
            traversal(cur->left, path, result);
            path.pop_back(); // 回溯
        }
        if (cur->right) { // 右
            traversal(cur->right, path, result);
            path.pop_back(); // 回溯
        }
    }

public:
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> result;
        vector<int> path;
        if (root == NULL) return result;
        traversal(root, path, result);
        return result;
    }
};
```
