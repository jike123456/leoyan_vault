## 150.逆波兰表达式求值

### 注意点
1. `long long`型的，乘法很容易出现整数溢出的情况。
2. 筛选的是`+-*/` 只需要四个或者`||`就行。
3. `string`类型的不管是`+-*/`，还是`'1'  '2' '10'`,得进行转换。
4. `push()`括号中可以直接进行运算。
5. 后出的在前面，也就是temp2。
6. `stoll()`是将string to long long；`stoi` 是 `int`；
7. `'+'`是ascii码的43，单个字符，而`"+"`则是字符串，后面实则还带着`\0` ,所以不能`tokens[i] == '+'` .
8. **`else`**：这是“剩下的所有情况”，**后面不能跟括号写条件**。`else(tokens[i] == "/")`；四个if更方便理解。
### demo
```cpp
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<long long> st;
        for(int i = 0; i < tokens.size(); i++){
            if(tokens[i] == "+" || tokens[i] == "-" || tokens[i] == "*" || tokens[i] == "/" ){
                long long temp1 = st.top();
                st.pop();
                long long temp2 = st.top();
                st.pop();
                if(tokens[i] == "+") st.push(temp2 + temp1);
                else if(tokens[i] == "-") st.push(temp2 - temp1);
                else if(tokens[i] == "*") st.push(temp2 * temp1);
                else st.push(temp2 / temp1);//用四个if也可
            }
            else{
                st.push(stoll(tokens[i]));
            }
        }
        return st.top();
    }
};
```
## 239.滑动窗口最大值
### 注意点
1. `deque:`双向队列，双向可查`front(),back()`，双向可加可删：`pop_back();push_back()`
2. 定义了一个单调递减的队列：==pop()== 在队列que不为空 并且 删除值等于此时的`front()`进行执行，否则实则已经被==push()==删除了;   ==push()==  如果队列是空直接push；如果队列不是空 并且 push的值大于队列末尾的值，对末尾进行一直删除`pop_back()`,直到push的值小于队尾，停止并把值加入;`front()`
3. 啥都没有，先把第一组队列push进去`nums[i]`。
4. 把i当成加入的值`que.push(nums[i])`，开始循环遍历到最后，pop则是删除i-k.
### demo
```cpp
class Solution {
public:
    class MyQueue{
    public:
        deque<int> que;
        void pop(int value){
            if(!que.empty() && value == que.front()){
                que.pop_front();
            }
        }
        void push(int value){
            while(!que.empty() && value > que.back()){
                que.pop_back();
            }
            que.push_back(value);
        }

        int front(){
            return que.front();
        }
    };
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        MyQueue que;
        vector<int> result;
        for(int i = 0; i < k; i++){
            que.push(nums[i]);
        }
        result.push_back(que.front());
        for(int i = k; i < nums.size(); i++){
            que.pop(nums[i-k]);
            que.push(nums[i]);
            result.push_back(que.front());
        }
        return result;
    }
};
```

## 347.前K个高频元素
