## 150.逆波兰表达式求值

### 注意点
1. `long long`型的，乘法很容易出现整数溢出的情况。
2. 筛选的是`+-*/` 只需要四个或者`||`就行。
3. `string`类型的不管是`+-*/`，还是`'1'  '2' '10'`,得进行转换。
4. `push()`括号中可以直接进行运算。
5. 后出的在前面，也就是temp2。
6. `stoll()`是将string to long long；`stoi` 是 `int`；
7. `'+'`是ascii码的43，单个字符，而`"+"`则是字符串，后面实则还带着`\0` ,所以不能`tokens[i] == '+'` .
8. **`else`**：这是“剩下的所有情况”，**后面不能跟括号写条件**。`else(tokens[i] == "/")`；四个if更方便理解。
### demo
```cpp
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<long long> st;
        for(int i = 0; i < tokens.size(); i++){
            if(tokens[i] == "+" || tokens[i] == "-" || tokens[i] == "*" || tokens[i] == "/" ){
                long long temp1 = st.top();
                st.pop();
                long long temp2 = st.top();
                st.pop();
                if(tokens[i] == "+") st.push(temp2 + temp1);
                else if(tokens[i] == "-") st.push(temp2 - temp1);
                else if(tokens[i] == "*") st.push(temp2 * temp1);
                else st.push(temp2 / temp1);//用四个if也可
            }
            else{
                st.push(stoll(tokens[i]));
            }
        }
        return st.top();
    }
};
```
## 239.滑动窗口最大值
