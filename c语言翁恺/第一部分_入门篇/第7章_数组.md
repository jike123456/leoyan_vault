# 第7章：数组 (Arrays)

## 1. 初识数组

数组是**相同类型**数据的容器。一旦创建，其**大小是固定**的（在 C99 变长数组 VLA 之前，且嵌入式通常禁用 VLA）。
可以把它想象成一排连续的储物柜，每个柜子大小一样，都有编号。

### 1.1 ==定义与基本语法==

```c
// 类型 数组名 [元素数量];
int grades[100]; 
double weight[20];
```

*   **元素数量**：必须是整数。在 C89 标准中，必须是编译期确定的常量（如 `10` 或 `#define N 10`）。
*   **类型**：数组中所有元素必须是同一种类型。

## 2. 数组的初始化

C 语言提供了多种初始化数组的方式，非常灵活。

```c
// 1. 全部初始化
int a[5] = {1, 2, 3, 4, 5};

// 2. 自动推断长度 (如果不写大小，编译器会根据初始化列表数)
int b[] = {1, 2, 3}; // 长度为 3

// 3. 部分初始化 (重要技巧)
// 如果初始化列表的元素少于数组长度，**剩下的元素会自动补 0**
int c[10] = {1}; // 第一个元素是 1，剩下 9 个全部是 0！
// 这是一个快速将大数组清零的好方法：
int buffer[1024] = {0}; 

// 4. 指定初始化 (C99 特性, 翁恺老师常用)
// 适合稀疏数组，只初始化特定的位置
int d[10] = {
    [0] = 1,
    [5] = 10,
    [9] = 100
};
```

## 3. 数组的访问与下标 (Index)

数组通过**下标**来访问元素。
**核心规则：下标==从 0 开始==，到 `n-1` 结束。**

对于 `int a[10];`：
*   第一个有效元素：`a[0]`
*   最后一个有效元素：`a[9]`
*   **`a[10]` 是无效的！**

```c
// 标准遍历写法
int a[5] = {10, 20, 30, 40, 50};
for (int i = 0; i < 5; i++) {
    printf("%d\n", a[i]);
}
```

## 4. 越界及其后果 (Out of Bounds) —— 危险区域

**C 编译器不会检查数组下标是否越界！**
你可以写 `a[100] = 0;`，编译器可能一声不吭，但程序运行时会发生可怕的事情。

### 为什么危险？
数组在内存中是**连续**存放的。数组结束后的内存空间可能存放着：
1.  其他局部变量。
2.  **函数的返回地址**（在栈上）。
3.  其他重要控制数据。

**在嵌入式系统中的后果**：
*   **改写变量**：莫名其妙的 Bug，变量 `i` 突然变了，循环停不下来。
*   **系统崩溃 (Hard Fault)**：改写了返回地址，CPU 跳转到非法区域执行指令。
*   **硬件异常**：如果数组映射到寄存器区域，越界可能误触硬件控制位。

## 5. ==数组大小的计算
==
在使用数组时，我们经常需要知道它有多大。

```c
int a[] = {1, 2, 3, 4, 5, 6, 7};
// 数组总字节数 / 单个元素字节数
int len = sizeof(a) / sizeof(a[0]); 
```

> **翁恺老师提示**：
> 这种写法具有**自适应性**。当你修改了初始化列表增加元素时，不需要去修改代码里的 `len`，程序会自动计算正确的大小。

## 6. 数组与函数 —— 数组的特殊性

这是初学者最容易晕的地方：**数组作为参数传递给函数时，性质发生了变化。**

```c
void print_array(int arr[], int length) {
    // 在这里，sizeof(arr) 不再是整个数组的大小！
    // arr 退化成了一个指针（地址），通常是 4 或 8 字节。
    for (int i = 0; i < length; i++) {
        printf("%d ", arr[i]);
    }
}

int main() {
    int data[10] = {0};
    // 必须在外面算好长度传进去，不能在函数内部算
    print_array(data, 10); 
    return 0;
}
```

*   **传址**：数组传入函数时，传递的是数组**首元素的首地址**。
*   **不拷贝**：函数内部修改 `arr[i]`，**会影响 main 函数里原始数组的内容**！这与普通变量的“传值”完全不同。

## 7. 二维数组

可以理解为“表格”或“矩阵”。

```c
// 3行 5列
int matrix[3][5]; 

// 初始化
int m[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};
```

*   **内存布局**：C 语言的二维数组是**按行优先 (Row-major)** 连续存储的。
    *   `m[0][0], m[0][1], m[0][2]` 紧接着是 `m[1][0]...`
*   **省略维度**：初始化时，只能省略第一维（行数），不能省略第二维（列数）。
    *   `int a[][3] = {{1,2,3}, {4,5,6}};` // 合法，自动推断为 2 行。
    *   `int a[2][] = ...;` // **非法！** 编译器必须知道一行有多宽，才能计算地址。

`count[i]++`:==数组i的值进行计数==；i有多少个。
## 8. 素数查找案例 (素数筛法)

这是数组最经典的应用之一（构造一张表）。

```c
// 构造一个标记数组，isPrime[x] == 1 表示 x 是素数
// 这种用下标代表具体数值的方法在嵌入式查表法中非常常用
int isPrime[100]; 
for(int i=0; i<100; i++) isPrime[i] = 1; // 假设全是素数

// 简单的埃氏筛法逻辑
for(int x=2; x<100; x++) {
    if(isPrime[x]) {
        for(int i=2*x; i<100; i+=x) {
            isPrime[i] = 0; // 把 x 的倍数标记为非素数
        }
    }
}
```