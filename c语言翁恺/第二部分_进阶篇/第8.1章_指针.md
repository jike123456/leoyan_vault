# 第8.1章：指针 (Pointers) —— C语言的灵魂

> **翁恺老师引言**：
> “指针是 C 语言的灵魂。如果你不懂指针，你就没学过 C 语言。指针是 C 语言赋予程序员直接操作内存的权利，它是强大的工具，也是危险的火种。”

## 1. 指针的本质：地址 (Address)

在计算机中，内存是一块巨大的连续空间。每一个字节（Byte）都有一个唯一的编号，这个编号就是**地址**。

*   **普通变量**：`int i = 10;` 就像是你预订了一个房间，给它取名叫 `i`，里面住了个人叫 `10`。
*   **指针变量**：`int *p = &i;` 就像是你拿了一张纸条，上面写的不是“人”，而是房间 `i` 的**门牌号**（地址）。

### 1.1 指针的大小
不管指针指向的是 `char` 还是 `double`，**指针本身的大小是固定的**。
*   在 32 位系统（如 STM32）中，地址总线是 32 位，所以指针占 **4 字节**。
*   在 64 位系统（如现代 PC）中，指针占 **8 字节**。

```c
printf("%d", sizeof(int*)); // STM32 上输出 4
printf("%d", sizeof(char*)); // STM32 上输出 4
```

## 2. 两个核心运算符：`&` 与 `*`

这是指针操作的一体两面。

*   **`&` (取地址)**：获取变量的门牌号。
    *   `scanf("%d", &i);` 这里的 `&` 就是为了告诉 `scanf` 把数据送到哪去。
*   **`*` (解引用/间接访问)**：根据门牌号，找到房间里的人。
    *   `*p` 可以看作是==变量 `i` 的**替身**==。修改 `*p` 就是修改 `i`。

```
int i = 10;
int *p = &i; // p 保存了 i 的地址
*p = 20;     // 等价于 i = 20;
```
注意理解`*p`与p是不一样的，一个是指针，一个是访问的值。
## 3. 指针的使用场景

为什么非要用指针？

### 场景一：函数返回多个值 (Output Parameters)
C 语言的 `return` 只能返回一个值。如果我们想在函数里修改外面的变量，或者带回多个结果（比如同时求最大值和最小值），必须用指针。

```c
// 同时找出数组的最大值和最小值
void min_max(int a[], int len, int *min, int *max) {
    *min = a[0];
    *max = a[0];
    for(int i=1; i<len; i++) {
        if(a[i] < *min) *min = a[i];
        if(a[i] > *max) *max = a[i];
    }
}

int main() {
    int a[] = {1, 3, 5, 2, 4};
    int min, max;
    min_max(a, 5, &min, &max); // 把 min 和 max 的地址传进去
    printf("min=%d, max=%d\n", min, max);
}
```

## 4. 指针与数组：亲密无间

在 C 语言中，数组的名字（在表达式中）大多会被编译器转化为**指向数组第一个元素的指针**。

*   `a` 等价于 `&a[0]`。
*   `a[i]` 等价于 `*(a + i)`。

### 4.1 指针运算 (Pointer Arithmetic)
这是 C 语言最神奇的地方。
*   `char *p; p++;` -> 地址 `+1` (sizeof(char))
*   `int *p; p++;` -> 地址 `+4` (sizeof(int))

**意义**：指针加 1，意味着让指针指向**下一个单元**，而不是下一个字节。

```c
int a[5];
int *p = a;
*(p + 2) = 100; // 等价于 a[2] = 100;
```

## 5. const 与指针 (初学者噩梦)

`const` 放在 `*` 的前面还是后面，意义完全不同。翁恺老师的口诀：**看 `*`**。

| 写法 | 含义 | 助记 |
| :--- | :--- | :--- |
| `const int *p` | `*p` 是 const <br> 不能通过 p 修改目标变量 <br> `*p = 20` (X) <br> `p = &j` (O) | **指针指向了常量** (Read-only view) |
| `int const *p` | 同上 | 同上 |
| `int * const p` | `p` 是 const <br> 指针变量本身不能变 <br> `*p = 20` (O) <br> `p = &j` (X) | **常指针** (指针是忠诚的) |
| `const int * const p` | 都是 const | 既不能改指向，也不能改内容 |

**应用**：
在函数参数中，如果不需要修改数组内容，**一定要加上 `const`**，既保护数据，也增加代码可读性。
`int printf(const char *format, ...);`

## 6. void* 指针

`void*` 表示“不知道指向什么类型的指针”。
*   它是通用指针，任何类型的指针都可以赋值给 `void*`。
*   **限制**：不能对 `void*` 进行解引用 (`*p`) 或算术运算 (`p++`)，因为编译器不知道它指向的数据有多大。必须先强制类型转换。

```c
int i = 10;
void *p = &i;
// *p = 20; // 错误！
*(int*)p = 20; // 正确，先转为 int*
```

## 7. 嵌入式特供：访问硬件地址

在嵌入式开发中，寄存器就是内存地址。我们需要用指针“强行”访问某个特定的物理地址。

```c
// 定义：将 0x40021018 强制转换为 int 指针，并解引用
#define GPIOA_ODR  (*((volatile unsigned int *)0x40021018))

// 使用
GPIOA_ODR = 0xFFFF; // 向该地址写入数据
```

*   **`volatile`**：非常重要！告诉编译器这个变量可能被硬件（或中断）偷偷修改，不要去优化它（比如不要把它缓存在寄存器里，每次都要老老实实去读写内存）。

## 8. 常见错误

1.  **野指针 (Wild Pointer)**：定义指针但未初始化。
    ```c
    int *p; 
    *p = 100; // 灾难！p 指向哪里是随机的，可能改写了系统关键数据。
    ```
2.  **空指针 (NULL)**：
    ```c
    int *p = NULL;
    // *p = 100; // 崩溃！在许多系统中，访问地址 0 会触发硬件异常。
    ```
    **习惯**：如果不确定指针指哪里，先初始化为 `NULL`。使用前检查 `if (p != NULL)`。

```